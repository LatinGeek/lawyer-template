"use strict";
(self["webpackChunkendless"] = self["webpackChunkendless"] || []).push([["default-src_app_shared_data_chart_chartist_ts-node_modules_ng2-google-charts_fesm2015_ng2-goo-36e96a"],{

/***/ 20732:
/*!***********************************************!*\
  !*** ./src/app/shared/data/chart/chartist.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "chart1": () => (/* binding */ chart1),
/* harmony export */   "chart10": () => (/* binding */ chart10),
/* harmony export */   "chart11": () => (/* binding */ chart11),
/* harmony export */   "chart12": () => (/* binding */ chart12),
/* harmony export */   "chart2": () => (/* binding */ chart2),
/* harmony export */   "chart3": () => (/* binding */ chart3),
/* harmony export */   "chart4": () => (/* binding */ chart4),
/* harmony export */   "chart5": () => (/* binding */ chart5),
/* harmony export */   "chart6": () => (/* binding */ chart6),
/* harmony export */   "chart7": () => (/* binding */ chart7),
/* harmony export */   "chart8": () => (/* binding */ chart8),
/* harmony export */   "chart9": () => (/* binding */ chart9)
/* harmony export */ });
/* harmony import */ var chartist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chartist */ 97103);
/* harmony import */ var chartist__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chartist__WEBPACK_IMPORTED_MODULE_0__);

var seq = 0;
var delays = 80;
var durations = 500;
// Chart 1 Advanced SMIL Animations
var chart1 = {
    type: 'Line',
    data: {
        labels: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
        series: [
            [12, 9, 7, 8, 5, 4, 6, 2, 3, 3, 4, 6],
            [4, 5, 3, 7, 3, 5, 5, 3, 4, 4, 5, 5],
            [5, 3, 4, 5, 6, 3, 3, 4, 5, 6, 3, 4],
            [3, 4, 5, 6, 7, 6, 4, 5, 6, 7, 6, 3]
        ]
    },
    options: {
        low: 0,
        showArea: false,
        fullWidth: true,
        height: 450,
    },
    events: {
        draw: (data) => {
            seq++;
            if (data.type === 'line') {
                data.element.animate({
                    opacity: {
                        begin: seq * delays + 1000,
                        dur: durations,
                        from: 0,
                        to: 1
                    }
                });
            }
            else if (data.type === 'label' && data.axis === 'x') {
                data.element.animate({
                    y: {
                        begin: seq * delays,
                        dur: durations,
                        from: data.y + 100,
                        to: data.y,
                        easing: 'easeOutQuart'
                    }
                });
            }
            else if (data.type === 'label' && data.axis === 'y') {
                data.element.animate({
                    x: {
                        begin: seq * delays,
                        dur: durations,
                        from: data.x - 100,
                        to: data.x,
                        easing: 'easeOutQuart'
                    }
                });
            }
            else if (data.type === 'point') {
                data.element.animate({
                    x1: {
                        begin: seq * delays,
                        dur: durations,
                        from: data.x - 10,
                        to: data.x,
                        easing: 'easeOutQuart'
                    },
                    x2: {
                        begin: seq * delays,
                        dur: durations,
                        from: data.x - 10,
                        to: data.x,
                        easing: 'easeOutQuart'
                    },
                    opacity: {
                        begin: seq * delays,
                        dur: durations,
                        from: 0,
                        to: 1,
                        easing: 'easeOutQuart'
                    }
                });
            }
            else if (data.type === 'grid') {
                var pos1Animation = {
                    begin: seq * delays,
                    dur: durations,
                    from: data[data.axis.units.pos + '1'] - 30,
                    to: data[data.axis.units.pos + '1'],
                    easing: 'easeOutQuart'
                };
                var pos2Animation = {
                    begin: seq * delays,
                    dur: durations,
                    from: data[data.axis.units.pos + '2'] - 100,
                    to: data[data.axis.units.pos + '2'],
                    easing: 'easeOutQuart'
                };
                var animations = {};
                animations[data.axis.units.pos + '1'] = pos1Animation;
                animations[data.axis.units.pos + '2'] = pos2Animation;
                animations['opacity'] = {
                    begin: seq * delays,
                    dur: durations,
                    from: 0,
                    to: 1,
                    easing: 'easeOutQuart'
                };
                data.element.animate(animations);
            }
        }
    }
};
// Chart 2 SVG Path animation
var chart2 = {
    type: 'Line',
    data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        series: [
            [1, 5, 2, 5, 4, 3],
            [2, 3, 4, 8, 1, 2],
            [5, 4, 3, 2, 1, 0.5]
        ]
    },
    options: {
        low: 0,
        showArea: true,
        showPoint: false,
        fullWidth: true,
        height: 450,
    },
    events: {
        draw: (data) => {
            if (data.type === 'line' || data.type === 'area') {
                data.element.animate({
                    d: {
                        begin: 2000 * data.index,
                        dur: 2000,
                        from: data.path.clone().scale(1, 0).translate(0, data.chartRect.height()).stringify(),
                        to: data.path.clone().stringify(),
                        easing: chartist__WEBPACK_IMPORTED_MODULE_0__.Svg.Easing.easeOutQuint
                    }
                });
            }
        }
    }
};
// Chart 3 Animating a Donut with Svg.animate
var chart3 = {
    type: 'Pie',
    data: {
        series: [10, 20, 50, 20, 5, 50, 15],
        labels: [1, 2, 3, 4, 5, 6, 7]
    },
    options: {
        donut: true,
        showLabel: false,
        height: 450,
    },
    events: {
        draw: (data) => {
            if (data.type === 'slice') {
                var pathLength = data.element._node.getTotalLength();
                data.element.attr({
                    'stroke-dasharray': pathLength + 'px ' + pathLength + 'px'
                });
                var animationDefinition = {
                    'stroke-dashoffset': {
                        id: 'anim' + data.index,
                        dur: 1000,
                        from: -pathLength + 'px',
                        to: '0px',
                        easing: chartist__WEBPACK_IMPORTED_MODULE_0__.Svg.Easing.easeOutQuint,
                        fill: 'freeze'
                    }
                };
                data.element.attr({
                    'stroke-dashoffset': -pathLength + 'px'
                });
                data.element.animate(animationDefinition, false);
            }
        }
    }
};
// Chart 4 Bi-polar Line chart with area only
var chart4 = {
    type: 'Line',
    data: {
        labels: [1, 2, 3, 4, 5, 6, 7, 8],
        series: [
            [1, 2, 3, 1, -2, 0, 1, 0],
            [-2, -1, -2, -1, -2.5, -1, -2, -1],
            [0, 0, 0, 1, 2, 2.5, 2, 1],
            [2.5, 2, 1, 0.5, 1, 0.5, -1, -2.5]
        ]
    },
    options: {
        high: 3,
        low: -3,
        showArea: true,
        showLine: false,
        showPoint: false,
        fullWidth: true,
        axisX: {
            showLabel: false,
            showGrid: false
        },
        height: 450,
    }
};
// Chart 5 Line chart with area
var chart5 = {
    type: 'Line',
    data: {
        labels: [1, 2, 3, 4, 5, 6, 7, 8],
        series: [
            [5, 9, 7, 8, 5, 3, 5, 4]
        ]
    },
    options: {
        low: 0,
        showArea: true,
        height: 450,
    }
};
// Chart 6 Bi-polar bar chart
var chart6 = {
    type: 'Bar',
    data: {
        labels: ['W1', 'W2', 'W3', 'W4', 'W5', 'W6', 'W7', 'W8', 'W9', 'W10'],
        series: [
            [1, 2, 4, 8, 6, -2, -1, -4, -6, -2]
        ]
    },
    options: {
        high: 10,
        low: -10,
        axisX: {
            labelInterpolationFnc: function (value, index) {
                return index % 2 === 0 ? value : null;
            }
        },
        height: 450,
    }
};
// Chart 7 Stacked bar chart
var chart7 = {
    type: 'Bar',
    data: {
        labels: ['Mon', 'Tue', 'wen', 'Thus', 'Fri', 'Sat', 'Sun'],
        series: [
            [3, 3, 0, 2, 0, 3, 0],
            [2, null, 1.5, null, 3.5, 2, 3],
        ]
    },
    options: {
        stackBars: true,
        scaleMinSpace: 90,
        height: 450,
    }
};
// Chart 8 Horizontal bar chart
var chart8 = {
    type: 'Bar',
    data: {
        labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        series: [
            [5, 4, 3, 7, 5, 10, 3],
            [3, 2, 9, 5, 4, 6, 4]
        ]
    },
    options: {
        seriesBarDistance: 10,
        reverseData: true,
        horizontalBars: true,
        axisY: {
            offset: 70
        },
        height: 450,
    }
};
// Chart 9 Extreme responsive configuration
var chart9 = {
    type: 'Bar',
    data: {
        labels: ['2010-11', '2011-12', '2012-13', '2013-13', '2014-15', '2015-16', '2016-17', '2017-18'],
        series: [
            [0.9, 0.4, 1.5, 4.9, 3, 3.8, 3.8, 1.9],
            [6.4, 5.7, 7, 4.95, 3, 3.8, 3.8, 1.9],
            [4.3, 2.3, 3.6, 4.5, 5, 2.8, 3.3, 4.3],
            [3.8, 4.1, 2.8, 1.8, 2.2, 1.9, 6.7, 2.9]
        ]
    },
    options: {
        height: 450,
        seriesBarDistance: 15,
        horizontalBars: false,
        axisY: {
            offset: 20
        }
    },
};
// Chart 10 Simple line chart
var chart10 = {
    type: 'Line',
    data: {
        labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],
        series: [
            [12, 9, 7, 8, 5],
            [2, 1, 3.5, 7, 3],
            [1, 3, 4, 5, 6]
        ]
    },
    options: {
        height: 450,
        fullWidth: true,
        chartPadding: {
            right: 40
        }
    },
};
//Chart11: Holes in data
var chart11 = {
    type: 'Line',
    data: {
        labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
        series: [
            [5, 5, 10, 8, 7, 5, 4, null, null, null, 10, 10, 7, 8, 6, 9],
            [10, 15, null, 12, null, 10, 12, 15, null, null, 12, null, 14, null, null, null],
            [null, null, null, null, 3, 4, 1, 3, 4, 6, 7, 9, 5, null, null, null]
            //	[{x:3, y: 3},{x: 4, y: 3}, {x: 5, y: undefined}, {x: 6, y: 4}, {x: 7, y: null}, {x: 8, y: 4}, {x: 9, y: 4}]
        ]
    },
    options: {
        height: 450,
        fullWidth: true,
        chartPadding: {
            right: 10
        },
        low: 0
    },
};
// // Chart 12 Filled holes in data
var chart12 = {
    type: 'Line',
    data: {
        labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
        series: [
            [5, 5, 10, 8, 7, 5, 4, null, null, null, 10, 10, 7, 8, 6, 9],
            [10, 15, null, 12, null, 10, 12, 15, null, null, 12, null, 14, null, null, null],
            [null, null, null, null, 3, 4, 1, 3, 4, 6, 7, 9, 5, null, null, null]
            //	[{x:3, y: 3},{x: 4, y: 3}, {x: 5, y: undefined}, {x: 6, y: 4}, {x: 7, y: null}, {x: 8, y: 4}, {x: 9, y: 4}]
        ]
    },
    options: {
        height: 450,
        fullWidth: true,
        chartPadding: {
            right: 10
        },
        lineSmooth: chartist__WEBPACK_IMPORTED_MODULE_0__.Interpolation.cardinal({
            fillHoles: true,
        }),
        low: 0
    },
};


/***/ }),

/***/ 29970:
/*!**********************************************************************!*\
  !*** ./node_modules/ng2-google-charts/fesm2015/ng2-google-charts.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChartHTMLTooltip": () => (/* binding */ ChartHTMLTooltip),
/* harmony export */   "GoogleChartComponent": () => (/* binding */ GoogleChartComponent),
/* harmony export */   "GoogleChartEditor": () => (/* binding */ GoogleChartEditor),
/* harmony export */   "GoogleChartType": () => (/* binding */ GoogleChartType),
/* harmony export */   "GoogleChartsControlComponent": () => (/* binding */ GoogleChartsControlComponent),
/* harmony export */   "GoogleChartsDashboardComponent": () => (/* binding */ GoogleChartsDashboardComponent),
/* harmony export */   "GoogleChartsLoaderService": () => (/* binding */ GoogleChartsLoaderService),
/* harmony export */   "Ng2GoogleChartsModule": () => (/* binding */ Ng2GoogleChartsModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ 34929);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 3184);




class GoogleChartsDataTable {
  constructor(opt) {
    this.opt = opt;
    this.dataTableChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();

    if (opt) {
      this._setDataTable(opt.dataTable, opt.firstRowIsData);
    }
  }

  send() {
    if (this.query === undefined) {
      return;
    }

    this.query.send(queryResponse => {
      this.setDataTable(queryResponse.getDataTable());

      if (this.opt.queryCallback) {
        this.opt.queryCallback(queryResponse);
      }
    });
  }

  init(opt) {
    if (opt) {
      this.opt = opt;
    }

    if (this.tid !== undefined) {
      // doesn't work, see https://github.com/google/google-visualization-issues/issues/2381
      // this.query.abort();
      window.clearInterval(this.tid);
      this.tid = undefined;
    }

    if (this.opt.dataSourceUrl) {
      this.query = new google.visualization.Query(this.opt.dataSourceUrl);

      if (this.opt.query) {
        this.query.setQuery(this.opt.query);
      }

      if (this.opt.timeout !== undefined) {
        this.query.setTimeout(this.opt.timeout);
      }

      if (this.opt.refreshInterval) {
        // this.query.setRefreshInterval(this.opt.refreshInterval);
        this.tid = window.setInterval(() => {
          this.send();
        }, this.opt.refreshInterval * 1000);
      }

      this.send();
    } else {
      this.setDataTable(this.opt.dataTable);
    }
  }
  /**
   * @returns Underlying google.visualization.DataTable
   */


  getDataTable() {
    return this.dataTable;
  }

  setDataTable(dt, firstRowIsData) {
    if (firstRowIsData === undefined) {
      firstRowIsData = this.opt.firstRowIsData;
    }

    this._setDataTable(dt, firstRowIsData);

    this.dataTableChanged.emit(this.dataTable);
  }

  _setDataTable(dt, firstRowIsData) {
    if (Array.isArray(dt)) {
      dt = google.visualization.arrayToDataTable(dt, firstRowIsData);
    }

    this.dataTable = dt;
    this.reformat();
  }
  /**
   * Applies formatters to data columns, if defined
   */


  reformat() {
    const dt = this.dataTable;

    if (dt === undefined) {
      return;
    }

    if (this.opt.formatters === undefined) {
      return;
    }

    for (const formatterConfig of this.opt.formatters) {
      let formatter;

      if (formatterConfig.type === 'PatternFormat') {
        const fmtOptions = formatterConfig.options;
        formatter = new google.visualization.PatternFormat(fmtOptions.pattern);
        formatter.format(dt, formatterConfig.columns, fmtOptions.dstColumnIndex);
        continue;
      }

      const formatterConstructor = google.visualization[formatterConfig.type];
      const formatterOptions = formatterConfig.options;
      formatter = new formatterConstructor(formatterOptions);

      if (formatterConfig.type === 'ColorFormat' && formatterOptions) {
        const fmtOptions = formatterOptions;

        if (fmtOptions.ranges) {
          for (const range of fmtOptions.ranges) {
            if (typeof range.fromBgColor !== 'undefined' && typeof range.toBgColor !== 'undefined') {
              formatter.addGradientRange(range.from, range.to, range.color, range.fromBgColor, range.toBgColor);
            } else {
              formatter.addRange(range.from, range.to, range.color, range.bgcolor);
            }
          }
        }
      }

      for (const col of formatterConfig.columns) {
        formatter.format(dt, col);
      }
    }
  }

}

GoogleChartsDataTable.ɵfac = function GoogleChartsDataTable_Factory(t) {
  _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinvalidFactory"]();
};

GoogleChartsDataTable.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: GoogleChartsDataTable,
  outputs: {
    dataTableChanged: "dataTableChanged"
  }
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](GoogleChartsDataTable, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
  }], function () {
    return [{
      type: undefined
    }];
  }, {
    dataTableChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }]
  });
})();

class ChartHTMLTooltip {
  constructor(el) {
    this.el = el;
  }

  setPosition(x, y) {
    this.el.nativeElement.style.left = x + ChartHTMLTooltip.PIXELS;
    this.el.nativeElement.style.top = y + ChartHTMLTooltip.PIXELS;
  }

  getDOMElement() {
    return this.el;
  }

}

ChartHTMLTooltip.PIXELS = 'px';

class GoogleChartsLoaderService {
  constructor(localeId, googleChartsSettings) {
    this.googleChartsSettings = googleChartsSettings;
    this.loadedPackages = [];
    this.loaded = false;
    const defaultSettings = {
      googleChartsVersion: '50',
      language: localeId
    };
    this.googleChartsSettings = Object.assign(Object.assign({}, defaultSettings), this.googleChartsSettings);
    this.googleScriptLoadingNotifier = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.googleChartLoadingNotifier = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.googleScriptIsLoading = false;
    this.googleChartIsLoading = false;
    this.loadGoogleChartsScriptPromise = new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.charts) {
        resolve();
      } else if (!this.googleScriptIsLoading) {
        this.googleScriptIsLoading = true;
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'https://www.gstatic.com/charts/loader.js';
        script.async = true;
        script.defer = true;

        script.onload = () => {
          this.googleScriptIsLoading = false;
          this.googleScriptLoadingNotifier.emit(true);
          resolve();
        };

        script.onerror = () => {
          this.googleScriptIsLoading = false;
          this.googleScriptLoadingNotifier.emit(false);
          reject();
        };

        document.getElementsByTagName('head')[0].appendChild(script);
      } else {
        this.googleScriptLoadingNotifier.subscribe(loaded => {
          if (loaded) {
            resolve();
          } else {
            reject();
          }
        });
      }
    });
  }

  load(settings) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      yield this.loadGoogleChartsScriptPromise;
      yield new Promise(resolve => {
        if (this.googleChartIsLoading) {
          this.googleChartLoadingNotifier.subscribe(() => {
            this.doLoad(resolve, settings);
          });
          return;
        }

        this.doLoad(resolve, settings);
      });
    });
  }

  doLoad(resolve, settings) {
    settings = Object.assign(Object.assign({}, this.googleChartsSettings), settings);

    if (!settings.packages && this.loaded) {
      resolve();
      return;
    }

    if (settings.packages) {
      let pkgs = settings.packages.filter(p => this.loadedPackages.indexOf(p) < 0);

      if (pkgs.length == 0 && this.loaded) {
        resolve();
        return;
      }

      settings.packages = pkgs;
    }

    const _settings = settings;

    _settings.callback = () => {
      this.googleChartIsLoading = false;

      if (_settings.packages !== undefined) {
        this.loadedPackages = this.loadedPackages.concat(_settings.packages);
      }

      this.loaded = true;
      this.googleChartLoadingNotifier.emit();
      resolve();
    };

    this.googleChartIsLoading = true;
    google.charts.load(settings.googleChartsVersion, _settings);
  }

}

GoogleChartsLoaderService.ɵfac = function GoogleChartsLoaderService_Factory(t) {
  return new (t || GoogleChartsLoaderService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"]('googleChartsSettings', 8));
};

GoogleChartsLoaderService.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
  token: GoogleChartsLoaderService,
  factory: GoogleChartsLoaderService.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](GoogleChartsLoaderService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
        args: ['googleChartsSettings']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
      }]
    }];
  }, null);
})();

var GoogleChartType;

(function (GoogleChartType) {
  GoogleChartType["AnnotationChart"] = "AnnotationChart";
  GoogleChartType["AreaChart"] = "AreaChart";
  GoogleChartType["BarChart"] = "BarChart";
  GoogleChartType["BubbleChart"] = "BubbleChart";
  GoogleChartType["Calendar"] = "Calendar";
  GoogleChartType["CandlestickChart"] = "CandlestickChart";
  GoogleChartType["ColumnChart"] = "ColumnChart";
  GoogleChartType["ComboChart"] = "ComboChart";
  GoogleChartType["Gantt"] = "Gantt";
  GoogleChartType["Gauge"] = "Gauge";
  GoogleChartType["GeoChart"] = "GeoChart";
  GoogleChartType["Histogram"] = "Histogram";
  GoogleChartType["LineChart"] = "LineChart";
  GoogleChartType["Map"] = "Map";
  GoogleChartType["OrgChart"] = "OrgChart";
  GoogleChartType["PieChart"] = "PieChart";
  GoogleChartType["Sankey"] = "Sankey";
  GoogleChartType["ScatterChart"] = "ScatterChart";
  GoogleChartType["SteppedAreaChart"] = "SteppedAreaChart";
  GoogleChartType["Table"] = "Table";
  GoogleChartType["Timeline"] = "Timeline";
  GoogleChartType["TreeMap"] = "TreeMap";
  GoogleChartType["VegaChart"] = "VegaChart";
  GoogleChartType["WordTree"] = "WordTree";
})(GoogleChartType || (GoogleChartType = {}));

class GoogleChartComponent {
  constructor(el, loaderService) {
    this.el = el;
    this.loaderService = loaderService;

    this.selectListener = () => {
      const event = {
        message: 'select',
        row: null,
        column: null,
        selectedRowValues: [],
        selectedRowFormattedValues: [],
        columnLabel: ''
      };
      const s = this.wrapper.visualization.getSelection();
      const gs = s[s.length - 1];

      if (!gs) {
        event.message = 'deselect';
        return event;
      }

      const selection = gs;

      if (gs.row != null) {
        event.row = selection.row;
        const selectedRowValues = [];
        const selectedRowFormattedValues = [];
        const dataTable = this.wrapper.getDataTable();
        const numberOfColumns = dataTable.getNumberOfColumns();

        for (let i = 0; i < numberOfColumns; i++) {
          selectedRowValues.push(dataTable.getValue(selection.row, i));
          selectedRowFormattedValues.push(dataTable.getFormattedValue(selection.row, i));
        }

        event.selectedRowValues = selectedRowValues;
        event.selectedRowFormattedValues = selectedRowFormattedValues;
      }

      if (selection.column != null) {
        event.column = selection.column;
        event.columnLabel = this.getColumnLabelAtPosition(selection);
      }

      if (gs.name) {
        event.columnLabel = gs.name;
      }

      return event;
    };

    this.chartSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.chartSelectOneTime = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.chartReady = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.chartReadyOneTime = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.chartError = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.chartErrorOneTime = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.mouseOver = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.mouseOverOneTime = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.mouseOut = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.mouseOutOneTime = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.regionClick = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.regionClickOneTime = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
  }

  ngOnInit() {
    this.HTMLel = this.el.nativeElement.querySelector('div');

    if (Object.isExtensible(this.data)) {
      this.data.component = this;
    }

    this.options = this.data.options;
    this.init().then(() => {
      this.draw();
    });
  }

  init() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      yield this.loaderService.load();
      this.recreateWrapper();
    });
  }

  recreateWrapper() {
    if (this.wrapper === undefined || this.wrapper.getChartType() !== this.data.chartType) {
      this.dataTable = new GoogleChartsDataTable(this.data);
      this.dataTable.dataTableChanged.subscribe(dt => {
        this._draw();
      }); // see dataTable in https://developers.google.com/chart/interactive/docs/reference#google.visualization.drawchart

      let temp = this.data;

      if (this.data.firstRowIsData) {
        temp = Object.assign(temp, this.data);
        temp.dataTable = this.dataTable.getDataTable();
      }

      this.wrapper = new google.visualization.ChartWrapper(temp);
      this.registerChartWrapperEvents();
      /* Calling draw even without data is the only way to pass the HTMl element
         when using the chart in a dashboard. Don't do this in all other cases:
         it breaks formatters with remote data source, hence the conditional. */

      if (temp.dataTable === undefined && temp.dataSourceUrl === undefined) {
        try {
          this.wrapper.draw(this.HTMLel);
        } catch (err) {}
      }
    }
  }

  _draw() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      const dt = this.dataTable.getDataTable();

      if (dt === undefined) {
        return;
      }

      this.convertOptions();
      this.recreateWrapper();
      this.wrapper.setOptions(this.options);
      this.wrapper.setDataTable(dt);
      this.wrapper.draw(this.HTMLel);
    });
  }

  getDataTable() {
    return this.dataTable;
  }

  draw(value) {
    if (value === undefined) {
      value = this.data;
    }

    this.options = value.options;
    this.dataTable.init(value);
  }

  getSelectorBySeriesType(seriesType) {
    const selectors = {
      bars: 'bar#%s#%r',
      haxis: 'hAxis#0#label',
      line: 'point#%s#%r',
      legend: 'legendentry#%s',
      area: 'point#%s#%r'
    };
    const selector = selectors[seriesType];
    return selector;
  }
  /**
   * Given a column number, counts how many
   * columns have rol=="data". Those are mapped
   * one-to-one to the series array. When rol is not defined
   * a column of type number means a series column.
   * @param column to inspect
   */


  getSeriesByColumn(column) {
    let series = 0;
    const dataTable = this.wrapper.getDataTable();

    for (let i = column - 1; i >= 0; i--) {
      const role = dataTable.getColumnRole(i);
      const type = dataTable.getColumnType(i);

      if (role === 'data' || type === 'number') {
        series++;
      }
    }

    return series;
  }

  getBoundingBoxForItem(item) {
    let boundingBox = {
      top: 0,
      left: 0,
      width: 0,
      height: 0
    };

    if (this.cli) {
      const column = item.column;
      const series = this.getSeriesByColumn(column);
      const row = item.row;
      let seriesType = this.options.seriesType;

      if (this.options.series && this.options.series[series] && this.options.series[series].type) {
        seriesType = this.options.series[series].type;
      }

      if (seriesType) {
        let selector = this.getSelectorBySeriesType(seriesType);

        if (selector) {
          selector = selector.replace('%s', series + '').replace('%c', column + '').replace('%r', row + '');
          const box = this.cli.getBoundingBox(selector);

          if (box) {
            boundingBox = box;
          }
        }
      }
    }

    return boundingBox;
  }

  getValueAtPosition(position) {
    if (position.row == null) {
      return null;
    }

    const dataTable = this.wrapper.getDataTable();
    const value = dataTable.getValue(position.row, position.column);
    return value;
  }

  getColumnTypeAtPosition(position) {
    const dataTable = this.wrapper.getDataTable();
    const type = dataTable.getColumnType(position.column) || '';
    return type;
  }

  getColumnLabelAtPosition(position) {
    const dataTable = this.wrapper.getDataTable();
    const type = dataTable.getColumnLabel(position.column) || '';
    return type;
  }

  getHTMLTooltip() {
    const tooltipER = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef(this.el.nativeElement.querySelector('.google-visualization-tooltip'));
    return new ChartHTMLTooltip(tooltipER);
  }

  parseMouseEvent(item) {
    const chartType = this.wrapper.getChartType();
    let eventColumn = item.column;

    if (eventColumn == null) {
      switch (chartType) {
        case 'Timeline':
          eventColumn = this.wrapper.getDataTable().getNumberOfColumns() === 3 ? 0 : 1;
          break;

        default:
          eventColumn = 0;
      }
    }

    const eventRow = item.row;
    const myItem = {
      row: eventRow,
      column: eventColumn
    };
    const event = {
      position: item,
      boundingBox: this.getBoundingBoxForItem(myItem),
      value: this.getValueAtPosition(myItem),
      columnType: this.getColumnTypeAtPosition(myItem),
      columnLabel: this.getColumnLabelAtPosition(myItem)
    };
    return event;
  }

  registerChartEvents() {
    const chart = this.wrapper.getChart();
    this.cli = chart.getChartLayoutInterface ? chart.getChartLayoutInterface() : null;

    if (this.mouseOver.observers.length > 0) {
      google.visualization.events.addListener(chart, 'onmouseover', item => {
        const event = this.parseMouseEvent(item);
        event.tooltip = this.getHTMLTooltip();
        this.mouseOver.emit(event);
      });
    }

    if (this.mouseOverOneTime.observers.length > 0) {
      google.visualization.events.addOneTimeListener(chart, 'onmouseover', item => {
        const event = this.parseMouseEvent(item);
        event.tooltip = this.getHTMLTooltip();
        this.mouseOverOneTime.emit(event);
      });
    }

    if (this.mouseOut.observers.length > 0) {
      google.visualization.events.addListener(chart, 'onmouseout', item => {
        const event = this.parseMouseEvent(item);
        this.mouseOut.emit(event);
      });
    }

    if (this.mouseOutOneTime.observers.length > 0) {
      google.visualization.events.addOneTimeListener(chart, 'onmouseout', item => {
        const event = this.parseMouseEvent(item);
        this.mouseOutOneTime.emit(event);
      });
    }

    if (this.data.chartType === 'GeoChart') {
      if (this.regionClick.observers.length > 0) {
        google.visualization.events.addListener(chart, 'regionClick', item => {
          this.regionClick.emit(item);
        });
      }

      if (this.regionClickOneTime.observers.length > 0) {
        google.visualization.events.addOneTimeListener(chart, 'regionClick', item => {
          this.regionClick.emit(item);
        });
      }
    }
  }

  registerChartWrapperEvents() {
    google.visualization.events.addListener(this.wrapper, 'ready', () => {
      this.chartReady.emit({
        message: 'Chart ready'
      });
    });
    google.visualization.events.addOneTimeListener(this.wrapper, 'ready', () => {
      this.chartReadyOneTime.emit({
        message: 'Chart ready (one time)'
      });
      this.registerChartEvents();
    });
    google.visualization.events.addListener(this.wrapper, 'error', error => {
      this.chartError.emit(error);
    });
    google.visualization.events.addOneTimeListener(this.wrapper, 'error', error => {
      this.chartErrorOneTime.emit(error);
    });
    this.addListener(this.wrapper, 'select', this.selectListener, this.chartSelect);
    this.addOneTimeListener(this.wrapper, 'select', this.selectListener, this.chartSelectOneTime);
  }

  addListener(source, eventType, listenerFn, evEmitter) {
    google.visualization.events.addListener(source, eventType, () => {
      evEmitter.emit(listenerFn());
    });
  }

  addOneTimeListener(source, eventType, listenerFn, evEmitter) {
    google.visualization.events.addOneTimeListener(source, eventType, () => {
      evEmitter.emit(listenerFn());
    });
  }

  convertOptions() {
    try {
      this.options = google.charts[this.data.chartType].convertOptions(this.options);
    } catch (error) {
      return;
    }
  }

}

GoogleChartComponent.ɵfac = function GoogleChartComponent_Factory(t) {
  return new (t || GoogleChartComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](GoogleChartsLoaderService));
};

GoogleChartComponent.ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: GoogleChartComponent,
  selectors: [["google-chart"]],
  inputs: {
    data: "data"
  },
  outputs: {
    chartReady: "chartReady",
    chartReadyOneTime: "chartReadyOneTime",
    chartError: "chartError",
    chartErrorOneTime: "chartErrorOneTime",
    chartSelect: "chartSelect",
    chartSelectOneTime: "chartSelectOneTime",
    mouseOver: "mouseOver",
    mouseOverOneTime: "mouseOverOneTime",
    mouseOut: "mouseOut",
    mouseOutOneTime: "mouseOutOneTime",
    regionClick: "regionClick",
    regionClickOneTime: "regionClickOneTime"
  },
  decls: 1,
  vars: 0,
  template: function GoogleChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div");
    }
  },
  encapsulation: 2
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](GoogleChartComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
    args: [{
      selector: 'google-chart',
      template: '<div></div>'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
    }, {
      type: GoogleChartsLoaderService
    }];
  }, {
    data: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    chartReady: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    chartReadyOneTime: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    chartError: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    chartErrorOneTime: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    chartSelect: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    chartSelectOneTime: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    mouseOver: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    mouseOverOneTime: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    mouseOut: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    mouseOutOneTime: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    regionClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }],
    regionClickOneTime: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
    }]
  });
})();

class GoogleChartsDashboardComponent {
  constructor(el, loaderService) {
    this.el = el;
    this.loaderService = loaderService;
    this.el = el;
    this.loaderService = loaderService;
  }

  ngOnInit() {
    this.data.component = this;
    this.init().then(() => {
      if (!this.dataTable) {
        this.dataTable = new GoogleChartsDataTable(this.data);
        this.dataTable.dataTableChanged.subscribe(dt => {
          this._draw();
        });
      }

      this.draw();
    });
  }

  init() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      yield this.loaderService.load({
        packages: ['controls']
      });
      this.dashboard = new google.visualization.Dashboard(this.el.nativeElement.querySelector('div'));

      for (const b of this.data.bind) {
        let controls = b[0];
        let charts = b[1];

        if (!(controls instanceof Array)) {
          controls = [controls];
        }

        if (!(charts instanceof Array)) {
          charts = [charts];
        }

        for (const c of controls) {
          yield c.component.ensureInit();
        }

        for (const c of charts) {
          if (!c.component) {
            continue;
          }

          yield c.component.init();
          const data = c.component.data;

          if (data.dataTable !== undefined || data.dataSourceUrl !== undefined) {
            throw Error('dataTable and dataSourceUrl cannot be specified when ' + 'chart is drawn in a Dashboard');
          }
        }

        this.dashboard.bind(controls.map(x => x.component.wrapper), charts.map(x => x.component.wrapper));
      }
    });
  }

  draw(value) {
    this.dataTable.init(value);
  }

  _draw() {
    this.dashboard.draw(this.dataTable.getDataTable());
  }

}

GoogleChartsDashboardComponent.ɵfac = function GoogleChartsDashboardComponent_Factory(t) {
  return new (t || GoogleChartsDashboardComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](GoogleChartsLoaderService));
};

GoogleChartsDashboardComponent.ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: GoogleChartsDashboardComponent,
  selectors: [["google-charts-dashboard"]],
  inputs: {
    data: "data"
  },
  decls: 1,
  vars: 0,
  template: function GoogleChartsDashboardComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div");
    }
  },
  encapsulation: 2
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](GoogleChartsDashboardComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
    args: [{
      selector: 'google-charts-dashboard',
      template: '<div></div>'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
    }, {
      type: GoogleChartsLoaderService
    }];
  }, {
    data: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }]
  });
})();

class GoogleChartsControlComponent {
  constructor(el, loaderService) {
    this.el = el;
    this.loaderService = loaderService;
    this.el = el;
    this.loaderService = loaderService;
  }

  ngOnInit() {
    this.data.component = this;
  }

  ensureInit() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      if (this.wrapper) {
        return;
      }

      yield this.loaderService.load({
        packages: ['controls']
      });
      let opt;
      opt = Object.create(this.data);
      opt.containerId = this.el.nativeElement.querySelector('div');
      this.wrapper = new google.visualization.ControlWrapper(opt);
    });
  }

}

GoogleChartsControlComponent.ɵfac = function GoogleChartsControlComponent_Factory(t) {
  return new (t || GoogleChartsControlComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](GoogleChartsLoaderService));
};

GoogleChartsControlComponent.ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: GoogleChartsControlComponent,
  selectors: [["google-charts-control"]],
  inputs: {
    data: "data"
  },
  decls: 1,
  vars: 0,
  template: function GoogleChartsControlComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div");
    }
  },
  encapsulation: 2
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](GoogleChartsControlComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
    args: [{
      selector: 'google-charts-control',
      template: '<div></div>'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
    }, {
      type: GoogleChartsLoaderService
    }];
  }, {
    data: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }]
  });
})();

class Ng2GoogleChartsModule {}

Ng2GoogleChartsModule.ɵfac = function Ng2GoogleChartsModule_Factory(t) {
  return new (t || Ng2GoogleChartsModule)();
};

Ng2GoogleChartsModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
  type: Ng2GoogleChartsModule
});
Ng2GoogleChartsModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
  providers: [GoogleChartsLoaderService]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](Ng2GoogleChartsModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
    args: [{
      declarations: [GoogleChartComponent, GoogleChartsDashboardComponent, GoogleChartsControlComponent],
      providers: [GoogleChartsLoaderService],
      exports: [GoogleChartComponent, GoogleChartsDashboardComponent, GoogleChartsControlComponent]
    }]
  }], null, null);
})();

function isComponent(chart) {
  return chart.wrapper !== undefined;
}

class GoogleChartEditor {
  constructor(loaderService) {
    this.loaderService = loaderService;
  }

  createEditor() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      if (this.chartEditor !== undefined) {
        return;
      }

      yield this.loaderService.load({
        packages: ['charteditor']
      });
      this.chartEditor = new google.visualization.ChartEditor();
      google.visualization.events.addListener(this.chartEditor, 'ok', () => {
        const wrapper = this.chartEditor.getChartWrapper();
        this.comp.wrapper = wrapper;
        this.comp.data.chartType = wrapper.getChartType();

        if (this.comp.data.options !== undefined || Object.isExtensible(this.comp.data)) {
          this.comp.data.options = wrapper.getOptions();
        }

        this.comp.wrapper.draw();
      });
    });
  }

  openDialog(chart, options) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
      yield this.createEditor();
      return new Promise((resolve, reject) => {
        this.comp = isComponent(chart) ? chart : chart.component;
        google.visualization.events.addListener(this.chartEditor, 'ok', () => {
          resolve(this.comp.wrapper);
        });
        google.visualization.events.addListener(this.chartEditor, 'cancel', () => {
          reject();
        });
        this.chartEditor.openDialog(this.comp.wrapper, options);
      });
    });
  }

}

GoogleChartEditor.ɵfac = function GoogleChartEditor_Factory(t) {
  return new (t || GoogleChartEditor)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](GoogleChartsLoaderService));
};

GoogleChartEditor.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
  token: GoogleChartEditor,
  factory: GoogleChartEditor.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](GoogleChartEditor, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: GoogleChartsLoaderService
    }];
  }, null);
})();
/*
 * Public API Surface of ng2-google-charts
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-src_app_shared_data_chart_chartist_ts-node_modules_ng2-google-charts_fesm2015_ng2-goo-36e96a.js.map